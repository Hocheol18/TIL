<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
    </ul>
    <script>
        // 유사 배열 객체
        // 배열(Array), 객체(Object)

         const obj = {
            1: 10,
            2: 30,
            3 : 90,
            length : 3
        }

        // 배열
        // 관련 있는 데이터들을 하나의 변수에 할당
        // 자바스크립트에서는 명시적 타입이 X,
        // 여러 자료형을 가질 수 있음.
        // 많은 methods 들이 내장되어 있다.
        const numbers = [1,2,3]
        
        // 유사 배열 객체
        // key로 인덱스를 가짐
        // 값을 각각 가지고 있음
        // length 가지고 있음
        // JS에서 querySelectorAll이나 document.body.children으로 엘리먼트 가져오면 이런 경우 생김.

        const liList = document.querySelectorAll('li')
        // 대표적인 유사배열객체
        // 유사배열 객체
        // 인덱스와 length 속성을 가진 객체는
        // 일반적으로 유사배열객체로 간주함.
        console.log(liList['1'])
        console.log(numbers)
        // Array 객체인지 판별하기
        console.log(Array.isArray(liList))
        console.log(Array.isArray(numbers))

        // 배열보다 객체가 메모리 효율성에서 좋음.
        // 배열의 동작을 제한하거나, 가지고 있지 않는 동작을 추가하는 등
        // 커스터마이징이 가능함
        // 객체를 배열처럼 인덱스로 접근할 수 있다

        // 주의사항
        // map, filter 등의 배열 메서드 사용 못함.

        // Array의 Methods를 사용하려면, Array 로 형변환 하면 됨.
        // 유사 배열 객체 -> 배열로 변환

        // 첫 번째 방법
        // Array.from 사용
        const array1 = Array.from(liList)

        // 두 번째 방법
        // 전개 연산자(...) 사용
        const array2 = [...liList]
        // 얘는 object 안 된다. 

        // iterable 하지 않은, 일반 객체
        const array3 = Object.values(obj)
        console.log(obj)

        // 얕은 복사, 깊은 복사
        // 원시 타입 빼고는 다 얕은 복사
        function func(arr) {
            arr[0] = 10 // 주소 값을 찾아가서 변경
        }

        let arr = [1,2,3]
        func(arr)
        console.log(arr) // [10, 2, 3]


        {
            // 복사할 때 >> 원본 데이터도 변경됨.
            let numbers = [1,2,3]
            let newNumbers = numbers // 얕은 복사
            newNumbers[1] = 20
            console.log(numbers)    // [1, 20, 3]
            console.log(newNumbers) // [1, 20, 3]
        }

        // 깊은 복사 - 배열
        {
            // 복사할 때 >> 원본 데이터도 변경됨.
            let numbers = [1,2,3]
            // 스프레드 연산자 : 객체를 전개해서 각 요소를 개별적인 값으로 분리
            let newNumbers = [...numbers]     // 깊은 복사 > 원본 배열 변경 X
            newNumbers[1] = 20
            console.log(numbers)              // [1, 2, 3]
            console.log(newNumbers)           // [1, 20, 3]
        }

        // 객체의 깊은 복사
        {
            const obj = {
                1: 10,
                2: 30,
                3 : 90,
                length : 3
            }

            // 가장 간단한 방법
            let newObj = JSON.parse(JSON.stringify(obj))
            newObj[0] = 10
            console.log(obj)
            console.log(newObj)
        }

    </script>
</body>
</html>